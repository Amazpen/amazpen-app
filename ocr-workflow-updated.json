{
  "nodes": [
    {
      "parameters": {
        "formTitle": "העלאת מסמך OCR",
        "formFields": {
          "values": [
            {
              "fieldLabel": "העלה קבצים (תמונות או PDF)",
              "fieldType": "file",
              "acceptFileTypes": ".pdf,.jpg,.jpeg,.png,.gif,.bmp,.tiff,.webp",
              "multipleFiles": true
            }
          ]
        },
        "options": {
          "respondWithData": false
        }
      },
      "id": "n1",
      "name": "Upload Form",
      "type": "n8n-nodes-base.formTrigger",
      "typeVersion": 2.2,
      "position": [0, 0],
      "webhookId": "ocr-form-upload-v2"
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Split multiple uploaded files into separate n8n items\n// Form Trigger stores files as binary keys: file0, file1, file2, etc.\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const binary = item.binary;\n  if (!binary) continue;\n  \n  const keys = Object.keys(binary);\n  for (const key of keys) {\n    const file = binary[key];\n    if (!file) continue;\n    const mimeType = file.mimeType || '';\n    const fileName = file.fileName || 'unknown';\n    const ext = fileName.split('.').pop()?.toLowerCase() || '';\n    const isPdf = mimeType.includes('pdf') || ext === 'pdf';\n    \n    results.push({\n      json: {\n        is_pdf: isPdf,\n        mime_type: mimeType,\n        file_name: fileName,\n        source: 'upload',\n        file_key: key\n      },\n      binary: { data: file }\n    });\n  }\n}\n\nif (results.length === 0) {\n  return [{ json: { error: 'No files found in upload', source: 'upload' } }];\n}\n\nreturn results;"
      },
      "id": "n2",
      "name": "Split Files",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [224, 0]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 2,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "cond-pdf",
              "leftValue": "={{ $json.is_pdf }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "n3",
      "name": "Is PDF?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [448, 0]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// PDF OCR: Google Vision files:annotate (native PDF support) with image fallback\nconst binary = $input.item.binary;\nif (!binary || !binary.data) {\n  return [{ json: { raw_text: '', source: 'upload', file_type: 'pdf', ocr_method: 'none' }, binary: binary || {} }];\n}\n\nconst base64 = binary.data.data;\nconst mimeType = binary.data.mimeType || 'application/pdf';\n\n// Try Google Vision files:annotate (supports PDF natively)\ntry {\n  const visionResp = await this.helpers.httpRequest({\n    method: 'POST',\n    url: 'https://vision.googleapis.com/v1/files:annotate?key=AIzaSyD2cs8yuO_9JVNqKUPlF3TyOd1acwPBGpU',\n    headers: { 'Content-Type': 'application/json' },\n    body: {\n      requests: [{\n        inputConfig: {\n          content: base64,\n          mimeType: 'application/pdf'\n        },\n        features: [{ type: 'DOCUMENT_TEXT_DETECTION' }],\n        pages: [1, 2, 3, 4, 5]\n      }]\n    }\n  });\n  \n  let fullText = '';\n  const responses = visionResp.responses || [];\n  for (const resp of responses) {\n    const pages = resp.responses || [];\n    for (const page of pages) {\n      const annotation = page.fullTextAnnotation;\n      if (annotation && annotation.text) {\n        fullText += annotation.text + '\\n';\n      }\n    }\n  }\n  fullText = fullText.trim();\n  \n  if (fullText.length > 20) {\n    return [{ json: { raw_text: fullText, source: 'upload', file_type: 'pdf', ocr_method: 'google_vision_pdf' }, binary: binary }];\n  }\n} catch(e) {\n  // files:annotate failed, try images:annotate fallback\n}\n\n// Fallback: try images:annotate (works if PDF is single-page image-like)\ntry {\n  const imgResp = await this.helpers.httpRequest({\n    method: 'POST',\n    url: 'https://vision.googleapis.com/v1/images:annotate?key=AIzaSyD2cs8yuO_9JVNqKUPlF3TyOd1acwPBGpU',\n    headers: { 'Content-Type': 'application/json' },\n    body: {\n      requests: [{\n        image: { content: base64 },\n        features: [{ type: 'DOCUMENT_TEXT_DETECTION' }]\n      }]\n    }\n  });\n  \n  const text = imgResp?.responses?.[0]?.textAnnotations?.[0]?.description || '';\n  if (text.trim().length > 10) {\n    return [{ json: { raw_text: text.trim(), source: 'upload', file_type: 'pdf', ocr_method: 'google_vision_image_fallback' }, binary: binary }];\n  }\n} catch(e2) {}\n\nreturn [{ json: { raw_text: '', source: 'upload', file_type: 'pdf', ocr_method: 'failed' }, binary: binary }];"
      },
      "id": "n40",
      "name": "PDF OCR",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [672, -112]
    },
    {
      "parameters": {
        "operation": "binaryToPropery",
        "options": {}
      },
      "id": "n4",
      "name": "Extract Base64",
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [672, 160]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://vision.googleapis.com/v1/images:annotate",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "key",
              "value": "AIzaSyD2cs8yuO_9JVNqKUPlF3TyOd1acwPBGpU"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"requests\": [{\"image\": {\"content\": \"{{ $json.data }}\"}, \"features\": [{\"type\": \"DOCUMENT_TEXT_DETECTION\"}]}]\n}",
        "options": {}
      },
      "id": "n5",
      "name": "Google Vision OCR",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [896, 160]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Extract OCR text from Vision API response and restore binary\nconst text = $input.item.json?.responses?.[0]?.textAnnotations?.[0]?.description || '';\n\n// Retrieve original binary from Split Files node\nlet newBinary = {};\ntry {\n  const splitItems = $('Split Files').all();\n  const idx = $itemIndex;\n  if (splitItems[idx] && splitItems[idx].binary && splitItems[idx].binary.data) {\n    newBinary = { data: splitItems[idx].binary.data };\n  }\n} catch(e) {}\n\nreturn [{\n  json: {\n    raw_text: text.trim(),\n    source: 'upload',\n    file_type: 'image',\n    ocr_method: 'google_vision'\n  },\n  binary: newBinary\n}];"
      },
      "id": "n6",
      "name": "Set OCR Text",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 160]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Build context: fetch businesses list and prepare OCR text for AI\nconst SB = 'https://db.amazpenbiz.co.il';\nconst SK = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE3NzExNTM2NTMsImV4cCI6MTg5MzQ1NjAwMCwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlzcyI6InN1cGFiYXNlIn0.jO_qu5aNUaOZ0YBdfW5MbzdML-csEU9QkqoTGAx5yzY';\nconst authHeaders = { apikey: SK, Authorization: 'Bearer ' + SK };\n\nconst businesses = await this.helpers.httpRequest({\n  method: 'GET',\n  url: SB + '/rest/v1/businesses?select=id,name,tax_id&deleted_at=is.null&status=eq.active',\n  headers: authHeaders\n});\n\nlet businessesMd = '| ID | Name | Tax ID |\\n|---|---|---|\\n';\nfor (const b of businesses) {\n  businessesMd += '| ' + b.id + ' | ' + (b.name || '') + ' | ' + (b.tax_id || '') + ' |\\n';\n}\n\nconst ocrText = $input.item.json.raw_text || '';\nconst clean = ocrText.replace(/[\\t]{2,}/g, ' ').trim();\n\nreturn [{\n  json: {\n    raw_text: ocrText,\n    text: clean,\n    businesses_markdown: businessesMd,\n    source: $input.item.json.source || 'upload',\n    file_type: $input.item.json.file_type || 'image',\n    ocr_method: $input.item.json.ocr_method || 'unknown',\n    sender_name: 'Upload',\n    chat_id: 'upload'\n  },\n  binary: $input.item.binary || {}\n}];"
      },
      "id": "n9",
      "name": "Build Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1440, 0]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Identify which BUSINESS (the customer/buyer who RECEIVED the invoice) this document belongs to.\n\nDocument text:\n{{ $json.text }}\n\nBusinesses list:\n{{ $json.businesses_markdown }}\n\nMatch by tax ID (ח.פ. / ע.מ.) or business name. The business details usually appear BELOW the supplier header in the document.\nIf no match found, return empty strings for business_id, business_name, business_tax_id.",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "You are an expert at identifying Israeli businesses from invoice text.\nYour ONLY job is to identify which BUSINESS (buyer/customer) this document was sent TO.\nThe business name/tax ID typically appears in the middle or lower part of the document, NOT at the top (the top is usually the supplier/issuer).\n\nReturn ONLY the matched business info. Nothing else."
        }
      },
      "id": "n20",
      "name": "AI Match Business",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [1664, 0]
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list"
        },
        "options": {
          "temperature": 0
        }
      },
      "id": "n21",
      "name": "Business Match Model",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [1552, 224],
      "credentials": {
        "openAiApi": {
          "id": "ARGBLBvXvIQYSgg1",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\"business_id\":\"\",\"business_name\":\"\",\"business_tax_id\":\"\"}",
        "autoFix": true
      },
      "id": "n22",
      "name": "Business Parser",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [1776, 224]
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini"
        },
        "builtInTools": {},
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [1712, 432],
      "id": "04a1c6b8-c1f0-46ed-8f85-ff84bf030909",
      "name": "OpenAI Chat Model1",
      "credentials": {
        "openAiApi": {
          "id": "ARGBLBvXvIQYSgg1",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Fetch suppliers for the matched business\nconst SB = 'https://db.amazpenbiz.co.il';\nconst SK = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE3NzExNTM2NTMsImV4cCI6MTg5MzQ1NjAwMCwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlzcyI6InN1cGFiYXNlIn0.jO_qu5aNUaOZ0YBdfW5MbzdML-csEU9QkqoTGAx5yzY';\nconst authHeaders = { apikey: SK, Authorization: 'Bearer ' + SK };\n\nconst ai = $input.item.json.output || $input.item.json;\nconst ctx = $('Build Context').item.json;\nconst businessId = (ai.business_id || '').trim();\n\nlet suppliersMd = '| ID | Name | Tax ID |\\n|---|---|---|\\n';\nif (businessId) {\n  const suppliers = await this.helpers.httpRequest({\n    method: 'GET',\n    url: SB + '/rest/v1/suppliers?select=id,name,tax_id&business_id=eq.' + businessId + '&is_active=eq.true&deleted_at=is.null&order=name.asc',\n    headers: authHeaders\n  });\n  for (const s of suppliers) {\n    suppliersMd += '| ' + s.id + ' | ' + (s.name || '') + ' | ' + (s.tax_id || '') + ' |\\n';\n  }\n}\n\nreturn [{\n  json: {\n    text: ctx.text,\n    raw_text: ctx.raw_text,\n    source: ctx.source,\n    file_type: ctx.file_type,\n    ocr_method: ctx.ocr_method,\n    sender_name: ctx.sender_name,\n    chat_id: ctx.chat_id,\n    business_id: businessId || null,\n    business_name: ai.business_name || '',\n    business_tax_id: ai.business_tax_id || '',\n    suppliers_markdown: suppliersMd,\n    has_matched_business: !!businessId\n  },\n  binary: $input.item.binary || {}\n}];"
      },
      "id": "n23",
      "name": "Fetch Suppliers",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2032, 0]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=text: {{ $json.text }}",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "=You are an expert extraction algorithm for Israeli invoices and financial documents.\nOnly extract relevant information from the text.\nIf you do not know the value of an attribute asked to extract, you may omit the attribute's value.\n\nIMPORTANT: The document has TWO parties:\n1. The BUSINESS - the company that RECEIVED the invoice/service\n2. The SUPPLIER - the company that ISSUED the invoice/document\n\nTypically the supplier's name and details appear at the TOP of the document (letterhead, logo area).\nThe business (customer) details usually appear below.\n\n{{ $json.has_matched_business ? 'The business has already been identified:\\n- Business ID: ' + $json.business_id + '\\n- Business Name: ' + $json.business_name + '\\n- Business Tax ID: ' + $json.business_tax_id : 'No business was matched. Extract business_name and business_tax_id from the document text if visible.' }}\n\nSuppliers list for this business (match the issuer/seller to this list):\n{{ $json.suppliers_markdown }}\n\nIf the supplier is NOT in the list above, still extract supplier_name and supplier_tax_id from the document - leave supplier_id empty.\n\nIMPORTANT: Write dates in YYYY-MM-DD format.\nThe years must be logical (we are in 2026).\nIf the date is 0 or empty, use today's date.\n\nMatch the supplier to the suppliers list using name or tax ID. If matched, use the supplier's ID as supplier_id.\n\nIMPORTANT: For document_type, you MUST return one of these English values ONLY:\n- invoice (for חשבונית, חשבונית מס, חשבונית מס קבלה)\n- delivery_note (for תעודת משלוח)\n- credit_note (for חשבונית זיכוי, זיכוי)\n- payment (for קבלה, אישור תשלום)\n- summary (for מרכזת, ריכוז חשבוניות)\n- daily_entry (for מילוי יומי, רישום יומי, דוח יומי, נתוני יום, daily report, daily data)\nDo NOT return Hebrew text for document_type.\n\nFor daily_entry documents: these are daily business data forms that contain daily revenue (total register/קופה), employee hours, labor costs, discounts, and other daily operational metrics. They do NOT contain supplier info, invoice numbers, or VAT calculations.\n\nIMPORTANT: Extract ALL line items from the invoice/document as a structured array.\nEach item in the 'items' array must have:\n- description: the item/product name (in Hebrew if available)\n- quantity: numeric quantity purchased\n- unit_price: price per single unit\n- total: line total (quantity * unit_price)\nIf there are no individual line items, return an empty array [].\nDo NOT return items as a string - always use a JSON array."
        }
      },
      "id": "n10",
      "name": "AI Extract Data",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [2352, 0]
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list"
        },
        "options": {
          "temperature": 0
        }
      },
      "id": "n11",
      "name": "OpenAI Model",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [2224, 224],
      "credentials": {
        "openAiApi": {
          "id": "ARGBLBvXvIQYSgg1",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\"document_type\":\"\",\"document_number\":\"\",\"date\":\"YYYY-MM-DD\",\"supplier_name\":\"\",\"supplier_tax_id\":\"\",\"supplier_id\":\"\",\"business_name\":\"\",\"business_tax_id\":\"\",\"business_id\":\"\",\"items\":[{\"description\":\"\",\"quantity\":0,\"unit_price\":0,\"total\":0}],\"amount_before_vat\":0,\"vat_amount\":0,\"amount_after_vat\":0}",
        "autoFix": true
      },
      "id": "n12",
      "name": "Output Parser",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [2736, 240]
    },
    {
      "parameters": {},
      "id": "n13",
      "name": "Think",
      "type": "@n8n/n8n-nodes-langchain.toolThink",
      "typeVersion": 1,
      "position": [2576, 272]
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini"
        },
        "builtInTools": {},
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [2320, 432],
      "id": "820117f8-58de-40cb-a694-9b5bd98d5c7b",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "ARGBLBvXvIQYSgg1",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Prepare data for storage upload and DB insertion\nconst ai = $input.item.json.output || $input.item.json;\nconst ctx = $('Fetch Suppliers').item.json;\nconst fileType = ctx.file_type || 'image';\nconst ext = fileType === 'pdf' ? '.pdf' : '.jpg';\nconst fileName = Date.now() + '-' + Math.random().toString(36).substring(2, 8) + ext;\nconst storagePath = 'upload/' + fileName;\nconst contentType = fileType === 'pdf' ? 'application/pdf' : 'image/jpeg';\n\nconst typeMap = {\n  invoice: 'invoice',\n  delivery_note: 'delivery_note',\n  credit_note: 'credit_note',\n  payment: 'payment',\n  receipt: 'payment',\n  summary: 'summary',\n  daily_entry: 'daily_entry',\n  '\\u05d7\\u05e9\\u05d1\\u05d5\\u05e0\\u05d9\\u05ea': 'invoice',\n  '\\u05d7\\u05e9\\u05d1\\u05d5\\u05e0\\u05d9\\u05ea \\u05de\\u05e1': 'invoice',\n  '\\u05d7\\u05e9\\u05d1\\u05d5\\u05e0\\u05d9\\u05ea \\u05de\\u05e1 \\u05e7\\u05d1\\u05dc\\u05d4': 'invoice',\n  '\\u05d7\\u05e9\\u05d1\\u05d5\\u05e0\\u05d9\\u05ea \\u05e2\\u05e1\\u05e7\\u05d4': 'invoice',\n  '\\u05ea\\u05e2\\u05d5\\u05d3\\u05ea \\u05de\\u05e9\\u05dc\\u05d5\\u05d7': 'delivery_note',\n  '\\u05d7\\u05e9\\u05d1\\u05d5\\u05e0\\u05d9\\u05ea \\u05d6\\u05d9\\u05db\\u05d5\\u05d9': 'credit_note',\n  '\\u05d6\\u05d9\\u05db\\u05d5\\u05d9': 'credit_note',\n  '\\u05e7\\u05d1\\u05dc\\u05d4': 'payment',\n  '\\u05d0\\u05d9\\u05e9\\u05d5\\u05e8 \\u05ea\\u05e9\\u05dc\\u05d5\\u05dd': 'payment',\n  '\\u05de\\u05e8\\u05db\\u05d6\\u05ea': 'summary',\n  '\\u05e8\\u05d9\\u05db\\u05d5\\u05d6 \\u05d7\\u05e9\\u05d1\\u05d5\\u05e0\\u05d9\\u05d5\\u05ea': 'summary',\n  '\\u05de\\u05d9\\u05dc\\u05d5\\u05d9 \\u05d9\\u05d5\\u05de\\u05d9': 'daily_entry',\n  '\\u05e8\\u05d9\\u05e9\\u05d5\\u05dd \\u05d9\\u05d5\\u05de\\u05d9': 'daily_entry',\n  '\\u05d3\\u05d5\\u05d7 \\u05d9\\u05d5\\u05de\\u05d9': 'daily_entry',\n  '\\u05e0\\u05ea\\u05d5\\u05e0\\u05d9 \\u05d9\\u05d5\\u05dd': 'daily_entry'\n};\nconst dt = (ai.document_type || '').toLowerCase().trim();\n\nlet items = [];\nif (Array.isArray(ai.items)) {\n  items = ai.items.filter(item => item && item.description);\n} else if (typeof ai.items === 'string' && ai.items.trim()) {\n  try { items = JSON.parse(ai.items); } catch(e) { items = []; }\n}\n\nconst businessId = (ai.business_id && ai.business_id.trim()) ? ai.business_id.trim() : (ctx.business_id || null);\n\nreturn [{\n  json: {\n    storagePath,\n    contentType,\n    fileName,\n    fileType,\n    document_type: typeMap[dt] || 'invoice',\n    supplier_name: ai.supplier_name || '',\n    supplier_tax_id: ai.supplier_tax_id || '',\n    supplier_id: (ai.supplier_id && ai.supplier_id.trim()) ? ai.supplier_id.trim() : null,\n    business_id: businessId,\n    business_name: ai.business_name || ctx.business_name || '',\n    business_tax_id: ai.business_tax_id || ctx.business_tax_id || '',\n    document_number: ai.document_number || '',\n    date: ai.date || null,\n    amount_before_vat: ai.amount_before_vat || 0,\n    vat_amount: ai.vat_amount || 0,\n    amount_after_vat: ai.amount_after_vat || 0,\n    items: items,\n    raw_text: ctx.raw_text || '',\n    ocr_method: ctx.ocr_method || 'unknown',\n    source: ctx.source || 'upload',\n    chat_id: ctx.chat_id || '',\n    sender_name: ctx.sender_name || ''\n  },\n  binary: $input.item.binary || {}\n}];"
      },
      "id": "n14",
      "name": "Prepare Upload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2816, -16]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://db.amazpenbiz.co.il/storage/v1/object/ocr-documents/{{ $json.storagePath }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE3NzExNTM2NTMsImV4cCI6MTg5MzQ1NjAwMCwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlzcyI6InN1cGFiYXNlIn0.jO_qu5aNUaOZ0YBdfW5MbzdML-csEU9QkqoTGAx5yzY"
            },
            {
              "name": "apikey",
              "value": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE3NzExNTM2NTMsImV4cCI6MTg5MzQ1NjAwMCwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlzcyI6InN1cGFiYXNlIn0.jO_qu5aNUaOZ0YBdfW5MbzdML-csEU9QkqoTGAx5yzY"
            },
            {
              "name": "Content-Type",
              "value": "={{ $json.contentType }}"
            }
          ]
        },
        "sendBody": true,
        "contentType": "binaryData",
        "inputDataFieldName": "data",
        "options": {}
      },
      "id": "n15",
      "name": "Upload to Storage",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [3040, -16]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Save document, extracted data, and line items to Supabase\nconst SB = 'https://db.amazpenbiz.co.il';\nconst SK = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE3NzExNTM2NTMsImV4cCI6MTg5MzQ1NjAwMCwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlzcyI6InN1cGFiYXNlIn0.jO_qu5aNUaOZ0YBdfW5MbzdML-csEU9QkqoTGAx5yzY';\nconst h = { 'Content-Type': 'application/json', apikey: SK, Authorization: 'Bearer ' + SK, Prefer: 'return=representation' };\n\nconst prep = $('Prepare Upload').item.json;\nconst storagePath = prep.storagePath;\nconst imageUrl = SB + '/storage/v1/object/public/ocr-documents/' + storagePath;\nconst ocrEngine = prep.ocr_method || (prep.fileType === 'pdf' ? 'pdf_extract' : 'google_vision');\n\n// 1. Insert ocr_documents\nconst d1 = await this.helpers.httpRequest({\n  method: 'POST', url: SB + '/rest/v1/ocr_documents', headers: h,\n  body: {\n    source: prep.source, source_chat_id: prep.chat_id, source_sender_name: prep.sender_name,\n    image_url: imageUrl, image_storage_path: storagePath,\n    file_type: prep.fileType, status: 'pending',\n    document_type: prep.document_type,\n    business_id: prep.business_id,\n    ocr_engine: ocrEngine,\n    ocr_processed_at: new Date().toISOString()\n  }\n});\nconst docId = Array.isArray(d1) ? d1[0].id : d1.id;\nif (!docId) {\n  return [{ json: { error: 'Failed to insert document', details: d1 } }];\n}\n\n// 2. Insert ocr_extracted_data\nconst d2 = await this.helpers.httpRequest({\n  method: 'POST', url: SB + '/rest/v1/ocr_extracted_data', headers: h,\n  body: {\n    document_id: docId, raw_text: prep.raw_text,\n    supplier_name: prep.supplier_name, supplier_tax_id: prep.supplier_tax_id,\n    document_number: prep.document_number, document_date: prep.date,\n    subtotal: prep.amount_before_vat, vat_amount: prep.vat_amount,\n    total_amount: prep.amount_after_vat, matched_supplier_id: prep.supplier_id,\n    extraction_metadata: { items: prep.items, business_name: prep.business_name, business_tax_id: prep.business_tax_id, business_id: prep.business_id }\n  }\n});\nconst extractedDataId = Array.isArray(d2) ? d2[0].id : d2.id;\n\n// 3. Insert line items\nlet lineItemsCount = 0;\nif (extractedDataId && Array.isArray(prep.items) && prep.items.length > 0) {\n  for (let i = 0; i < prep.items.length; i++) {\n    const item = prep.items[i];\n    if (!item || !item.description) continue;\n    try {\n      await this.helpers.httpRequest({\n        method: 'POST', url: SB + '/rest/v1/ocr_extracted_line_items', headers: h,\n        body: {\n          extracted_data_id: extractedDataId,\n          line_number: i + 1,\n          description: item.description || '',\n          quantity: item.quantity || 0,\n          unit_price: item.unit_price || 0,\n          total: item.total || 0\n        }\n      });\n      lineItemsCount++;\n    } catch(e) {}\n  }\n}\n\nreturn [{ json: { success: true, document_id: docId, image_url: imageUrl, source: prep.source, business_id: prep.business_id, supplier_id: prep.supplier_id, line_items_saved: lineItemsCount, ocr_method: prep.ocr_method } }];"
      },
      "id": "n16",
      "name": "Save DB Records",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3264, -16]
    }
  ],
  "connections": {
    "Upload Form": {
      "main": [
        [
          {
            "node": "Split Files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Files": {
      "main": [
        [
          {
            "node": "Is PDF?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is PDF?": {
      "main": [
        [
          {
            "node": "PDF OCR",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract Base64",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PDF OCR": {
      "main": [
        [
          {
            "node": "Build Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Base64": {
      "main": [
        [
          {
            "node": "Google Vision OCR",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Vision OCR": {
      "main": [
        [
          {
            "node": "Set OCR Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set OCR Text": {
      "main": [
        [
          {
            "node": "Build Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Context": {
      "main": [
        [
          {
            "node": "AI Match Business",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Match Business": {
      "main": [
        [
          {
            "node": "Fetch Suppliers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Business Match Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Match Business",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Business Parser": {
      "ai_outputParser": [
        [
          {
            "node": "AI Match Business",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Business Parser",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Suppliers": {
      "main": [
        [
          {
            "node": "AI Extract Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Extract Data": {
      "main": [
        [
          {
            "node": "Prepare Upload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Extract Data",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "AI Extract Data",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Think": {
      "ai_tool": [
        [
          {
            "node": "AI Extract Data",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Output Parser",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Upload": {
      "main": [
        [
          {
            "node": "Upload to Storage",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload to Storage": {
      "main": [
        [
          {
            "node": "Save DB Records",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "ff51c7b117b2b1acb40d590902906ec640659bab28c38b8f77a79ec2a840b5b4"
  }
}
